#!/usr/bin/env bb

(ns tw.context
  (:require [babashka.fs :as fs]
            [clojure.edn :as edn]))

(def CONTEXT-DIR (str (fs/home) "/.config/teamwork-cli/"))
(def CONTEXT-FILE "data.edn")
(def CONTEXT-PATH (str CONTEXT-DIR CONTEXT-FILE))

(def context (atom nil))

(def blank-context 
  {:teamwork-base "https://your-team-url.teamwork.com/"
   :api-key "INSERT API KEY IN QUOTES"
   :next-id 100
   :tasks {}})

(defn create-context! []
  (fs/create-dirs CONTEXT-DIR)
  (spit CONTEXT-PATH blank-context)
  blank-context)

(defn save! []
  (spit CONTEXT-PATH @context))

(defn verify-context [context]
  (if (= blank-context context)
    (throw (ex-info "Your Teamwork base URL and API-Key need configured. Please update them" {:context-location CONTEXT-PATH})) 
    context))

(defn get-context []
  (or
    @context
    (reset! context
      (if (fs/exists? CONTEXT-PATH)
        (verify-context (edn/read-string (slurp CONTEXT-PATH)))
        (do (create-context!) (get-context))))))

(defn index-task [task]
  (swap! context assoc-in [:tasks (:id task)] (:next-id @context))
  (swap! context update :next-id inc)
  (assoc task :my-id (get (:tasks @context) (:id task))))


(comment
  ;; Reset
  (reset! context nil)

  ;; Creating the local context
  (create-context!)

  ;; Loading the context
  (get-context) 

  (:tasks (get-context))

  ;; Save context
  (save!)


)
(ns tw.client
  (:require [babashka.http-client :as http]
            [cheshire.core :as json]
            [tw.context :as context]))

(defn b64-encode [txt]
  (let [encoder (java.util.Base64/getEncoder)
        resultBytes (.encode encoder (.getBytes txt))]
    (String. resultBytes)))

(defn deep-merge [a & maps]
  (if (map? a)
    (apply merge-with deep-merge a maps)
    (apply merge-with deep-merge maps)))

(defn parse-body [req]
  (when (:body req)
    (json/parse-string (:body req) true)))

(defn -request 
  ([path fn] (-request path fn {}))
  ([path fn req-data] 
   (let [context (context/get-context)
         token (str "Basic " (b64-encode (:api-key context)))
         data (merge-with into {:throw false :headers {"Authorization" token}} req-data)
         req (fn (str (:teamwork-base context) path) data)]
    (parse-body req))))

(defn get [path & others] 
  (apply -request path http/get others))

(defn put [path & others] 
  (apply -request path http/put others))

(defn post [path & others] 
  (apply -request path http/post others))
(ns tw.tasks
  (:require [tw.client :as client]
            [tw.context :as context]
            [clojure.set :refer [map-invert]]
            [cheshire.core :as json]))

(def board-columns
  {"open" 628003
   "progress" 628004 
   "review" 628005
   "ready" 628006
   "staging" 628007
   "completed" 628008})

;; they dont give me a remaining or counter... so i guess i can just compare to the total returned per page and see what that means
(defn -get-tasks []
  (loop [page 1
         tasks []]
    (let [page-size 250
          body (client/get "/tasks.json"
                                   {:query-params {"page" page
                                                   "pageSize" page-size}})]
      (if (not= page-size (count (:todo-items body)))
        (into tasks (:todo-items body))
        (recur (inc page) (into tasks (:todo-items body)))))))

(defn index-task [task]
  (let [index (:tasks (context/get-context))
        task (if (string? (:id task)) (update task :id parse-long) task)]
    (if (contains? index (:id task))
      (assoc task :my-id (get index (:id task)))
      (context/index-task task))))

(defn index-tasks []
  (let [tasks (-get-tasks)]
    (map index-task tasks)
    true))

(defn lookup-table []
  (map-invert (:tasks (context/get-context))))

(defn get-task [task]
  (let [index (lookup-table)]
    (when (contains? index task) 
      (client/get (str "tasks/" (get index task) ".json")))))

(defn get-url [task-id]
  (let [context (context/get-context)
        index (lookup-table)]
    (str (:teamwork-base context) 
         "app/tasks/" 
         (get index task-id))))

(defn search [query]
  (->> (client/get "search.json" 
                   {:query-params 
                      {"searchFor" "tasks" 
                       "searchTerm" query}})
         :searchResult
         :tasks
         (map index-task)))

(defn add-task-to-board [task-id board]
  (let [column-id (get board-columns board)
        index (lookup-table)]
    (when (contains? index task-id)
      (client/post (str "/boards/columns/" column-id "/cards.json")
                   {:body (json/encode {:card {:taskId (get index task-id)}})}))))

(defn get-card-task [column-name card]
  {:column column-name
   :column-id (get board-columns column-name)
   :card-id (parse-long (:id card))
   :task-id (parse-long (:taskId card))})

(defn board-tasks [board]
  (let [column-id (get board-columns board)]
    (->>
      (client/get (str "/boards/columns/" column-id "/cards.json"))
      :cards
      (map #(get-card-task board %)))))

(defn get-boards []
  (reduce-kv (fn [m k _]
               (assoc m k (board-tasks k))) 
             {} board-columns))

(defn task-board [task-id]
  (->> (get-boards)
       vals
       (apply concat)
       (filter #(= task-id (:task-id %)))
       first))

(defn move-card [card-id old new]
  (let [new-col-id (get board-columns new)
        old-col-id (get board-columns old)]
    (client/put (str "boards/columns/cards/" card-id "/move.json") 
                  {:body (json/encode {:columnId new-col-id
                                       :oldColumnId old-col-id})})))

(defn move-task [task-id board]
  (let [index (lookup-table)] 
    (when (contains? index task-id) 
      (if-let [card (task-board (get index task-id))]
        (move-card (:card-id card) (:column card) board)
        (add-task-to-board task-id board)))))

(comment 

  (index-tasks)
  (count (-get-tasks))

  (get-task 1054)
  (get-url 277)

  (search "multiple elements")

  (board-tasks "open")
  (get-boards)

  (move-card 1827560 "review" "ready")

  (move-task 1054 "open")
  (move-task 1054 "progress")
  (move-task 1054 "review")
  (move-task 1054 "ready")
  (move-task 1054 "staging")


  (add-task-to-board 1054 "review")
  ;; get columns for development project
  (->> (client/get "projects/736024/boards/columns.json")
       :columns
       (map #((juxt :name :id) %)))


)



(ns tw
  (:require [tw.tasks :as tasks]
            [tw.context :as context]
            [babashka.cli :as cli]
            [clojure.string :as str]
            [clojure.pprint :refer [pprint]]))

(defn print-tasks! [cmd]
  (tasks/index-tasks)
  (context/save!)
  (println (str "Now tracking " (count (:tasks (context/get-context))) " tasks")))

(defn print-task! [cmd]
  (let [task-id (or (parse-long (first (:args cmd))) 0)]
    (pprint (tasks/get-task task-id))))

(defn print-task-url! [cmd]
  (let [task-id (or (parse-long (first (:args cmd))) 0)]
    (println (tasks/get-url task-id))))

(defn print-search! [cmd]
  (let [query (str/join " " (:args cmd))]
    (->> (tasks/search query)
         (map #(str (:my-id %) "\t-\t" (:name %)))
         (str/join "\n")
         println))
  (context/save!))

(defn move-task! [cmd]
  (let [task-id (or (parse-long (first (:args cmd))) 0)
        board (second (:args cmd))]
    (tasks/move-task task-id board)))

(def cli-opts
  {:task      {:alias   :t
               :desc    "A teamwork task id"
               :coerce [:long]
               :require true}})

(def table
  [{:cmds ["index"] :fn print-tasks! :desc "Index all current tasks"}
   {:cmds ["task"] :fn print-task! :desc "Get specific task by id"}
   {:cmds ["search"] :fn print-search! :desc "Search for tasks by query"}
   {:cmds ["move"] :fn move-task! :desc "Move a task to one of the boards"}
   {:cmds ["url"] :fn print-task-url! :desc "Get the URL of a task"}])

(defn help [_]
  (println
    (reduce (fn [acc, cmd]
              (str acc 
                   (str/join ", " (:cmds cmd)) "\n\t"
                   (:desc cmd) "\n")) 
            "" table)))

(def dispatch-table 
  (conj table {:cmds [] :fn help}))

(cli/dispatch dispatch-table *command-line-args*)
